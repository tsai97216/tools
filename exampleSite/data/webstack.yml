- taxonomy: 常用推薦
  icon: far fa-star
  links: 
    - title: GitHub
      logo: github.png
      url: https://github.com/
      description: 全球最大的代碼託管平台。
    - title: YouTube
      logo: default.webp
      url: https://www.youtube.com/
      description: 全球最大影片網站。
    - title: 劉明野的工具箱
      logo: default.webp
      url: https://tools.liumingye.cn/
      description: 強大的聚合搜尋與工具站。

- taxonomy: 人工智慧 (AI)
  icon: fas fa-robot
  links:
    - title: ChatGPT
      logo: default.webp
      url: https://chat.openai.com/
      description: OpenAI 開發的 AI 聊天機器人。
    - title: Gemini
      logo: default.webp
      url: https://gemini.google.com/
      description: Google 最強大的多模態 AI 模型。
    - title: DeepSeek
      logo: default.webp
      url: https://chat.deepseek.com/
      description: 深度求索，強大的開源編碼與推理模型。
    - title: Perplexity
      logo: default.webp
      url: https://www.perplexity.ai/
      description: 結合即時搜尋引擎的 AI 智慧問答。
    - title: Grok
      logo: default.webp
      url: https://grok.com/
      description: xAI 開發的 AI 助手。

- taxonomy: 社群通訊
  icon: fas fa-comments
  links:
    - title: Facebook
      logo: default.webp
      url: https://www.facebook.com/
      description: 全球最大的社群網站。
    - title: Messenger
      logo: default.webp
      url: https://www.messenger.com/
      description: Facebook 即時通訊網頁版。
    - title: Instagram
      logo: default.webp
      url: https://www.instagram.com/
      description: 分享照片與生活的社群平台。
    - title: Threads
      logo: default.webp
      url: https://www.threads.net/
      description: Meta 推出的文字對話社群。
    - title: X (Twitter)
      logo: default.webp
      url: https://x.com/
      description: 全球即時資訊與社群平台。
    - title: Discord
      logo: default.webp
      url: https://discord.com/
      description: 專為社群與遊戲玩家設計的通訊軟體。
    - title: Reddit
      logo: default.webp
      url: https://www.reddit.com/
      description: 國外熱門綜合討論區與社群。

- taxonomy: 遊戲娛樂
  icon: fas fa-gamepad
  list:
    - term: 米遊專區
      links:
        - title: HoYoLAB
          logo: default.webp
          url: https://www.hoyolab.com/
          description: 米哈遊官方遊戲社群 (原神、崩鐵、絕區零)。
        - title: 玉衡杯數據庫
          logo: default.webp
          url: https://homdgcat.wiki/
          description: 妮可少女維護的深度遊戲數據庫 (HomDGCat)。
        - title: Hakush.in
          logo: default.webp
          url: https://hakush.in/
          description: 知名遊戲解包與數據網 (Hakushin)。
    - term: 遊戲福利與資訊
      links:
        - title: IsThereAnyDeal
          logo: default.webp
          url: https://isthereanydeal.com/giveaways/
          description: 查詢遊戲歷史低價與免費贈送資訊。
        - title: SteamDB
          logo: default.webp
          url: https://steamdb.info/
          description: Steam 遊戲數據庫，查特價與歷史低價。
        - title: 4Gamers 限時免費
          logo: default.webp
          url: https://www.4gamers.com.tw/news/tag/%E9%99%90%E6%99%82%E5%85%8D%E8%B2%BB
          description: 台灣遊戲媒體整理的限免情報。
    - term: 雲端遊戲
      links:
        - title: CloudMoon
          logo: default.webp
          url: https://cloudmoon.com/
          description: 聚光燈雲遊戲，手機輕鬆玩 3A 大作。
    - term: 遊戲社群
      links:
        - title: APK.tw
          logo: default.webp
          url: https://apk.tw/
          description: 台灣知名的 Android 遊戲與軟體論壇。
        - title: NGA 玩家社區
          logo: default.webp
          url: https://bbs.nga.cn/
          description: 知名綜合遊戲精英玩家論壇。
    - term: 影音動漫
      links:
        - title: Netflix
          logo: default.webp
          url: https://www.netflix.com/tw/
          description: 全球知名影視串流平台。
        - title: Bilibili
          logo: default.webp
          url: https://www.bilibili.com/
          description: 嗶哩嗶哩，最大的二次元影音彈幕網。
        - title: 巴哈姆特動畫瘋
          logo: default.webp
          url: https://ani.gamer.com.tw/
          description: 正版高畫質動畫線上看。
        - title: Anime1
          logo: default.webp
          url: https://anime1.me/
          description: 簡潔的免費動畫線上看網站。
        - title: Pixiv
          logo: default.webp
          url: https://www.pixiv.net/
          description: 全球最大插畫與漫畫投稿社群。
        - title: Spotify
          logo: default.webp
          url: open.spotify.com
          description: 線上音樂串流平台。

- taxonomy: 實用工具
  icon: fas fa-archive
  list:
    - term: 線上工具
      links:
        - title: Alist
          logo: default.webp
          url: http://localhost:5244/
          description: 聚合多種網盤的檔案列表服務 (本機)。
        - title: Google 翻譯
          logo: default.webp
          url: https://translate.google.com.tw/
          description: 多國語言線上翻譯。
        - title: Cobalt
          logo: default.webp
          url: https://cobalt.tools/
          description: 無廣告、隱私友善的多平台影音下載工具。
        - title: Reurl
          logo: default.webp
          url: https://reurl.cc/main/tw
          description: 台灣常用的短網址產生器。
        - title: Canva
          logo: default.webp
          url: https://www.canva.com/zh_tw/
          description: 簡單好用的線上平面設計與繪圖工具。
        - title: Convertio
          logo: default.webp
          url: https://convertio.co/zh/
          description: 線上檔案格式轉換。
        - title: iLoveIMG
          logo: default.webp
          url: https://www.iloveimg.com/zh-tw
          description: 線上圖片編輯工具 (壓縮、裁剪、轉換)。
        - title: iLovePDF
          logo: default.webp
          url: https://www.ilovepdf.com/zh-tw
          description: 線上 PDF 處理工具 (合併、拆分、壓縮)。
        - title: TeraBox
          logo: default.webp
          url: https://www.terabox.com/
          description: 提供大容量免費空間的雲端硬碟。
        - title: VirusTotal
          logo: default.webp
          url: https://www.virustotal.com/gui/home/upload
          description: 線上病毒掃描，檢查檔案或網址是否安全。
        - title: Decrypt.day
          logo: default.webp
          url: https://decrypt.day/
          description: iOS 應用程式 IPA 解密與下載庫。
        - title: Discord Quest Script
          logo: default.webp
          url: javascript:void(0);
          description: 點擊按鈕複製 Discord 自動解任務腳本 (F12 Console 使用)。
          is_copy: true
          copy_content: |
            delete window.$;let wpRequire = webpackChunkdiscord_app.push([[Symbol()], {}, r => r]);webpackChunkdiscord_app.pop();let ApplicationStreamingStore = Object.values(wpRequire.c).find(x => x?.exports?.Z?.__proto__?.getStreamerActiveStreamMetadata).exports.Z;let RunningGameStore = Object.values(wpRequire.c).find(x => x?.exports?.ZP?.getRunningGames).exports.ZP;let QuestsStore = Object.values(wpRequire.c).find(x => x?.exports?.Z?.__proto__?.getQuest).exports.Z;let ChannelStore = Object.values(wpRequire.c).find(x => x?.exports?.Z?.__proto__?.getAllThreadsForParent).exports.Z;let GuildChannelStore = Object.values(wpRequire.c).find(x => x?.exports?.ZP?.getSFWDefaultChannel).exports.ZP;let FluxDispatcher = Object.values(wpRequire.c).find(x => x?.exports?.Z?.__proto__?.flushWaitQueue).exports.Z;let api = Object.values(wpRequire.c).find(x => x?.exports?.tn?.get).exports.tn;let quest = [...QuestsStore.quests.values()].find(x => x.id !== "1412491570820812933" && x.userStatus?.enrolledAt && !x.userStatus?.completedAt && new Date(x.config.expiresAt).getTime() > Date.now())
            let isApp = typeof DiscordNative !== "undefined"
            if(!quest) {
                console.log("You don't have any uncompleted quests!")} else {
                const pid = Math.floor(Math.random() * 30000) + 1000
                const applicationId = quest.config.application.id
                const applicationName = quest.config.application.name
                const questName = quest.config.messages.questName
                const taskConfig = quest.config.taskConfig ?? quest.config.taskConfigV2
                const taskName = ["WATCH_VIDEO", "PLAY_ON_DESKTOP", "STREAM_ON_DESKTOP", "PLAY_ACTIVITY", "WATCH_VIDEO_ON_MOBILE"].find(x => taskConfig.tasks[x] != null)
                const secondsNeeded = taskConfig.tasks[taskName].target
                let secondsDone = quest.userStatus?.progress?.[taskName]?.value ?? 0
                if(taskName === "WATCH_VIDEO" || taskName === "WATCH_VIDEO_ON_MOBILE") {
                    const maxFuture = 10, speed = 7, interval = 1
                    const enrolledAt = new Date(quest.userStatus.enrolledAt).getTime()
                    let completed = false
                    let fn = async () => {          
                        while(true) {
                            const maxAllowed = Math.floor((Date.now() - enrolledAt)/1000) + maxFuture
                            const diff = maxAllowed - secondsDone
                            const timestamp = secondsDone + speed
                            if(diff >= speed) {
                                const res = await api.post({url: `/quests/${quest.id}/video-progress`, body: {timestamp: Math.min(secondsNeeded, timestamp + Math.random())}})
                                completed = res.body.completed_at != null
                                secondsDone = Math.min(secondsNeeded, timestamp)
                            }
                            if(timestamp >= secondsNeeded) {
                                break
                            }
                            await new Promise(resolve => setTimeout(resolve, interval * 1000))
                        }
                        if(!completed) {
                            await api.post({url: `/quests/${quest.id}/video-progress`, body: {timestamp: secondsNeeded}})
                        }
                        console.log("Quest completed!")
                    }
                    fn()
                    console.log(`Spoofing video for ${questName}.`)
                } else if(taskName === "PLAY_ON_DESKTOP") {
                    if(!isApp) {
                        console.log("This no longer works in browser for non-video quests. Use the discord desktop app to complete the", questName, "quest!")
                    } else {
                        api.get({url: `/applications/public?application_ids=${applicationId}`}).then(res => {
                            const appData = res.body[0]
                            const exeName = appData.executables.find(x => x.os === "win32").name.replace(">","")
                            const fakeGame = {
                                cmdLine: `C:\\Program Files\\${appData.name}\\${exeName}`,
                                exeName,
                                exePath: `c:/program files/${appData.name.toLowerCase()}/${exeName}`,
                                hidden: false,
                                isLauncher: false,
                                id: applicationId,
                                name: appData.name,
                                pid: pid,
                                pidPath: [pid],
                                processName: appData.name,
                                start: Date.now(),
                            }
                            const realGames = RunningGameStore.getRunningGames()
                            const fakeGames = [fakeGame]
                            const realGetRunningGames = RunningGameStore.getRunningGames
                            const realGetGameForPID = RunningGameStore.getGameForPID
                            RunningGameStore.getRunningGames = () => fakeGames
                            RunningGameStore.getGameForPID = (pid) => fakeGames.find(x => x.pid === pid)
                            FluxDispatcher.dispatch({type: "RUNNING_GAMES_CHANGE", removed: realGames, added: [fakeGame], games: fakeGames})
                            let fn = data => {
                                let progress = quest.config.configVersion === 1 ? data.userStatus.streamProgressSeconds : Math.floor(data.userStatus.progress.PLAY_ON_DESKTOP.value)
                                console.log(`Quest progress: ${progress}/${secondsNeeded}`)
                                if(progress >= secondsNeeded) {
                                    console.log("Quest completed!")
                                    RunningGameStore.getRunningGames = realGetRunningGames
                                    RunningGameStore.getGameForPID = realGetGameForPID
                                    FluxDispatcher.dispatch({type: "RUNNING_GAMES_CHANGE", removed: [fakeGame], added: [], games: []})
                                    FluxDispatcher.unsubscribe("QUESTS_SEND_HEARTBEAT_SUCCESS", fn)
                                }
                            }
                            FluxDispatcher.subscribe("QUESTS_SEND_HEARTBEAT_SUCCESS", fn)
                            console.log(`Spoofed your game to ${applicationName}. Wait for ${Math.ceil((secondsNeeded - secondsDone) / 60)} more minutes.`)
                        })
                    }
                } else if(taskName === "STREAM_ON_DESKTOP") {
                    if(!isApp) {
                        console.log("This no longer works in browser for non-video quests. Use the discord desktop app to complete the", questName, "quest!")
                    } else {
                        let realFunc = ApplicationStreamingStore.getStreamerActiveStreamMetadata
                        ApplicationStreamingStore.getStreamerActiveStreamMetadata = () => ({
                            id: applicationId,
                            pid,
                            sourceName: null
                        })
                        let fn = data => {
                            let progress = quest.config.configVersion === 1 ? data.userStatus.streamProgressSeconds : Math.floor(data.userStatus.progress.STREAM_ON_DESKTOP.value)
                            console.log(`Quest progress: ${progress}/${secondsNeeded}`)
                            if(progress >= secondsNeeded) {
                                console.log("Quest completed!")
                                ApplicationStreamingStore.getStreamerActiveStreamMetadata = realFunc
                                FluxDispatcher.unsubscribe("QUESTS_SEND_HEARTBEAT_SUCCESS", fn)
                            }
                        }
                        FluxDispatcher.subscribe("QUESTS_SEND_HEARTBEAT_SUCCESS", fn)
                        console.log(`Spoofed your stream to ${applicationName}. Stream any window in vc for ${Math.ceil((secondsNeeded - secondsDone) / 60)} more minutes.`)
                        console.log("Remember that you need at least 1 other person to be in the vc!")
                    }
                } else if(taskName === "PLAY_ACTIVITY") {
                    const channelId = ChannelStore.getSortedPrivateChannels()[0]?.id ?? Object.values(GuildChannelStore.getAllGuilds()).find(x => x != null && x.VOCAL.length > 0).VOCAL[0].channel.id
                    const streamKey = `call:${channelId}:1`
                    let fn = async () => {
                        console.log("Completing quest", questName, "-", quest.config.messages.questName)
                        while(true) {
                            const res = await api.post({url: `/quests/${quest.id}/heartbeat`, body: {stream_key: streamKey, terminal: false}})
                            const progress = res.body.progress.PLAY_ACTIVITY.value
                            console.log(`Quest progress: ${progress}/${secondsNeeded}`)
                            await new Promise(resolve => setTimeout(resolve, 20 * 1000))
                            if(progress >= secondsNeeded) {
                                await api.post({url: `/quests/${quest.id}/heartbeat`, body: {stream_key: streamKey, terminal: true}})
                                break
                            }
                        }
                        console.log("Quest completed!")
                    }
                    fn()
                }}
